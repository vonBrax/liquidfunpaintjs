import { Vector2f } from '../util/vector2f';
import { Log } from '../util/functionsHelper';
import { ByteBuffer } from '../util/byte-buffer';

/**
 * This is a static buffer for storing generated points per pointer.
 * We allow PointerInfo to use this buffer in blocks.
 * Could be implemented as a ring buffer but currently we are going to throw
 * errors on memory overflow.
 */
class PointerInputBuffer {
  private TAG: string;

  static FLUSH_LIMIT = 40;

  // 2 times flush limit for enough padding
  static BLOCK_SIZE = PointerInputBuffer.FLUSH_LIMIT * 2;

  // Assume maximum of 40 unique pointers on a screen
  static TOTAL_BUFFER_SIZE = PointerInputBuffer.BLOCK_SIZE * 40;

  mByteBuffer: ByteBuffer;
  mBufferEnd = 0;

  constructor(tag?: string) {
    this.TAG = tag;
    this.mByteBuffer = new ByteBuffer(PointerInputBuffer.TOTAL_BUFFER_SIZE);
    this.mByteBuffer.nativeOrder();
    this.mByteBuffer.createEmbindBuffer();
  }

  getNewBlock(): number {
    const newBlock: number = this.mBufferEnd;
    this.mBufferEnd += PointerInputBuffer.BLOCK_SIZE;

    if (this.mBufferEnd >= PointerInputBuffer.TOTAL_BUFFER_SIZE) {
      Log.e(
        this.TAG,
        'Buffer overflow in sGeneratedPointes! Increase buffer size or decrease flush size.',
      );
    }

    return newBlock;
  }

  putPoint(index: number, point: Vector2f): number {
    let currIndex = index;

    this.mByteBuffer.putFloat(currIndex, point.x);
    currIndex += 4;
    this.mByteBuffer.putFloat(currIndex, point.y);
    currIndex += 4;

    return currIndex;
  }

  reset(): void {
    this.mByteBuffer.clear();
    this.mBufferEnd = 0;
  }

  getRawBuffer(): ByteBuffer {
    return this.mByteBuffer;
  }
}

/**
 * Maps each pointer ID to the particle group and the coordinate
 * Pointer ID is returned by MotionEvent.getPointerId() and it indicates
 * each separate touch registered.
 * We want each touch (e.g. each finger that is touching the screen) to
 * generate a different ParticleGroup, if it applies.
 * mx, my is the last point generated by user
 */
export class PointerInfo {
  static TAG = 'PointerInfo';
  private mPointerId: number;

  /**
   * This is stored because we make a new PointerInfo before we are able
   * to get the first worldPoint it should cache (via init()).
   * It also allows us to determine if this is the first time we've seen
   * this pointer id.
   */
  private mNewPointer = true;
  private mGroup: ParticleGroup = null;
  private mWorldPoint: Vector2f = null;
  private mBufferBlockStart = -1;
  private mBufferBlockCurrent = -1;
  private mNumPoints = 0;

  private static PointerInputBuffer: PointerInputBuffer;

  // The actual buffer for storing pointer inputs
  private static sPointerInputBuffer = new PointerInputBuffer(PointerInfo.TAG);

  // Static methods
  static resetGlobalBuffer(): void {
    this.sPointerInputBuffer.reset();
  }

  // Member methods
  constructor(pointerId: number) {
    this.mPointerId = pointerId;
  }

  isNewPointer(): boolean {
    return this.mNewPointer;
  }

  getPointerId(): number {
    return this.mPointerId;
  }

  getParticleGroup(): ParticleGroup {
    return this.mGroup;
  }

  setParticleGroup(pGroup: ParticleGroup): void {
    this.mGroup = pGroup;
  }

  getBufferStart(): number {
    return this.mBufferBlockStart;
  }

  getNumPoints(): number {
    return this.mNumPoints;
  }

  getRawPointsBuffer(): ByteBuffer {
    return PointerInfo.sPointerInputBuffer.getRawBuffer();
  }

  getWorldPoint(): Vector2f {
    return this.mWorldPoint;
  }

  /**
   * Initializes this PointerInfo
   * @param worldPoint The initial point
   * @param storeInput If true, we need to grab a buffer block for storage.
   */
  init(worldPoint: Vector2f, storeInput: boolean): void {
    if (this.isNewPointer()) {
      this.mWorldPoint = new Vector2f(worldPoint);
      if (storeInput) {
        this.mBufferBlockStart = PointerInfo.sPointerInputBuffer.getNewBlock();
        this.mBufferBlockCurrent = this.mBufferBlockStart;
      }
    }
  }

  update(worldPoint: Vector2f): void {
    this.mNewPointer = false;
    this.mWorldPoint.set(worldPoint);
    this.putPoint(worldPoint);
  }

  putPoint(point: Vector2f): void {
    if (this.mBufferBlockStart !== -1) {
      // Error checking
      if (
        this.mBufferBlockCurrent - this.mBufferBlockStart >=
        PointerInputBuffer.BLOCK_SIZE
      ) {
        Log.e(
          PointerInfo.TAG,
          'Overflow in a PointerInputBuffer block. Increase block size or decrease flush limit.',
        );
      } else {
        this.mBufferBlockCurrent = PointerInfo.sPointerInputBuffer.putPoint(
          this.mBufferBlockCurrent,
          point,
        );
        ++this.mNumPoints;
      }
    }
  }

  needsFlush(): boolean {
    return (
      this.mBufferBlockCurrent !== -1 &&
      this.mBufferBlockCurrent - this.mBufferBlockStart >=
        PointerInputBuffer.FLUSH_LIMIT
    );
    // return true;
  }

  resetBuffer(): void {
    this.mBufferBlockCurrent = this.mBufferBlockStart;
    this.mNumPoints = 0;
  }
}
